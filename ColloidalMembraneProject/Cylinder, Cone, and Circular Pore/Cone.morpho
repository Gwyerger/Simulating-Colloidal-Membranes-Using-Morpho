import meshgen
import meshtools
import plot
import optimize
import moviemaker
import vtk
import functionals

// This code creates and optimizes conical frustum meshes. Given the two radii, the hieght is specified by a fixed area.



fn modulus(a, b){
    return (a/b - floor(a/b))*b
}

// Making the Mesh
fn CreateAndSaveMesh(R, r, H, Grain, str){
    if (R > 0){
        var mesh = AreaMesh(fn (u, v) [(R - (R-r)/H*v)*cos(u), (R - (R-r)/H*v)*sin(u), v],-Pi...Pi:Grain,0..H:Grain*H/sqrt(H^2 + (R-r)^2), closed=[true, false])
        mesh.addgrade(1)
        mesh.addgrade(2)
        var vtkME = VTKExporter(mesh)
        vtkME.export(String(str,".vtk"))
        // Show(plotmesh(mesh, grade=[0,1,2]))
        print(String("Cone mesh created and exported as ",str,".vtk"))
        return mesh
    }
}

 // //Initialize a field
fn AddNematicFieldEnergy(mesh, problem, IC, K, q) {
    var nn
    if (IC == "random") {
    nn = Field(mesh, fn(x,y,z) Matrix([cos(2*Pi*random()),cos(2*Pi*random()),cos(2*Pi*random())])) 
    }
    if (IC == "normal") {
    nn = Field(mesh, fn(x,y,z) Matrix([Matrix([1,0,0]).normal(), Matrix([0,1,0]).normal(),Matrix([0,0,1]).normal()])) 
    }
    if (IC == "uniform"){
    nn = Field(mesh, fn(x,y,z) Matrix([1, 0, 0])) 
    }
    var nem = Nematic(nn, ksplay = K, ktwist = K, kbend = K, pitch = q)
    problem.addenergy(nem)
    return [nn, nem]
}

// Add a tilt energy functional C/2*sin^2(theta)
fn tIntegrand(x, n) {                   
    return 1/2*(1-(n.normal())^2)
}

fn AddTiltEnergy(problem, nn, C) {
    var tilt = AreaIntegral(tIntegrand, nn) 
    problem.addenergy(tilt, prefactor = C)
}

fn AddConstraints(problem, reg, nn, R) {
    var lnorm = NormSq(nn)                      
    problem.addlocalconstraint(lnorm, field=nn, target=1) 
    var lcons = ScalarPotential(fn (x,y,z) (x^2 + y^2 - R^2))  
    reg.addlocalconstraint(lcons)     
}

fn CreateOptimizers(problem, reg, mesh, nn) {
    // Create the field optimizer
    var fopt = FieldOptimizer(problem, nn)
    fopt.stepsize = 0.001
    fopt.quiet = true
    var leq = EquiElement()                     // Try to equalize elements
    reg.addenergy(leq, prefactor = 1)
    var ropt = ShapeOptimizer(reg, mesh)
    ropt.quiet = true
    return [fopt, ropt]
}

fn Optimization(str, mesh, nn, fopt) {

    print(String("Optimizing mesh and exporting with batch name ", str))
    var vtkE = VTKExporter(nn)
    var h = 0
    var run = 60
    for (i in 0..run) {        
        if (modulus(i, 2)==0) {
        vtkE.export("/mnt/c/Users/gabey/OneDrive/Desktop/Fall 2023/SM Research/Cylinder Stuff/VTKs/${str}_${h}.vtk")
        print(String(h, "/", run/2))
        h = h+1
        }
        fopt.relax(4)
        fopt.conjugategradient(6)
    }
}

for (i in 0..9) {

    var r = 1
    var R = 1+0.2*i
    var Ar = Pi*8
    var H = sqrt(Ar^2/(Pi^2*(R+r)^2) - (R-r)^2)
    var K = 1
    var C = 1
    var q = 1

    CreateAndSaveMesh(R, r, H, dx, String("ConeR",R,"r",r))
    var vtkMI = VTKImporter(String("ConeR",R,"r",r,".vtk"))
    var mesh = vtkMI.mesh()
    var problem = OptimizationProblem(mesh)
    var reg = OptimizationProblem(mesh)           // Create the Auxiliary regularization problem (unused)
    var fe = AddNematicFieldEnergy(mesh, problem, "radial", K, q)
    var nn = fe[0]
    var nem = fe[1]
    AddTiltEnergy(problem, nn, C)
    AddConstraints(problem, reg, nn, R)
    var opts = CreateOptimizers(problem, reg, mesh, nn)
    var fopt = opts[0]
    Optimization(String("ConeR",R, "r",r,"q",0) , mesh, nn, fopt)
}